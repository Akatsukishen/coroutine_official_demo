import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking

/**
 *
 * runBlocking创建一个协程作用域，并在作用域的代码未执行完的情况下一直【阻塞】底层线程的执行。
 * launch 创建并启动协程
 *
 * 【协程】 必须在【协程作用域】里面才能创建。
 *
 * 协程作用域：类似于部门经理
 * 协程: 类似于部门经理下的员工
 *
 * 【协程作用域】统筹整个作用域的操作(取消/停止)，那么下面的协程全部响应其动作(取消/停止）
 * 协程各自独立完成自己的工作
 * 当各个协程完成自己的工作后，整个作用域的工作也就完成了
 *
 * 类似于：
 * 部门经理分配任务给下面的每个人
 * 每个人在自己的【小房间】独立完成自己的任务
 * 部门经理等待自身和下面的每个人的任务完成
 * 只有自身和下面的员工的任务完成了，才算完成了整个部门的工作。
 * 当然：部门经理收到上级任务暂停的命令后，可以统筹部门所有人的工作暂停。
 *
 */
fun main() =  runBlocking{
    //launch 在协程作用域下面创建一个协程，类似于部门经理给其他人分配一个任务，让他在一个专属的会议室里完成
    launch {
        //delay 挂起函数，挂起协程一段时间。协程挂起并不会阻塞下面的线程执行，允许其他协程来使用其底层协程。
        //可以挂起的意思：
        // 员工碰到一个可能要占用【小房间】很久的任务（delay)，不想过多占用公告资源，
        // 【让出】小房间，自己【挂起】到小房间的天花板上，等待在天花板上干活长时间的活后，自己下来【恢复】对小房间的使用
        delay(1000)
        println("world!")
    }
    //部门经理自己的任务
    print("Hello,")
    //等待所有任务完成之后，协程作用域结束
}